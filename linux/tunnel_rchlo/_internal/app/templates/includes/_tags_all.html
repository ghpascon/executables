<!-- Tags Table Widget -->
<div
  class="bg-white rounded-lg shadow border p-4 flex flex-col w-full h-[75vh]"
  x-data="tagDetailsTable()"
>
  <div class="justify-between flex items-center mb-4 flex-shrink-0">
    <h4 class="text-lg font-semibold">
      Tags (<span x-text="tags.length"></span>)
    </h4>
  </div>

  <div class="border rounded overflow-hidden flex-1">
    <div class="overflow-x-auto overflow-y-auto h-full">
      <table x-show="headers.length > 0" class="min-w-full border-collapse">
        <thead class="bg-gray-50 sticky top-0">
          <tr>
            <template x-for="header in headers" :key="header">
              <th
                class="px-2 py-2 text-left whitespace-nowrap border-b-2 border-gray-200 font-mono text-xs font-semibold text-gray-900"
                x-text="header.replace(/_/g, ' ').toUpperCase()"
              ></th>
            </template>
          </tr>
        </thead>
        <tbody>
          <template x-for="(tag, index) in tags" :key="`tag-${index}`">
            <tr class="border-b border-gray-200 hover:bg-gray-50">
              <template
                x-for="(header, headerIndex) in headers"
                :key="`cell-${index}-${headerIndex}`"
              >
                <td
                  class="px-2 py-2 font-mono text-xs sm:text-sm whitespace-nowrap text-gray-900"
                  :title="tag[header]"
                  x-text="formatValue(tag[header], header)"
                ></td>
              </template>
            </tr>
          </template>
        </tbody>
      </table>

      <div x-show="tags.length === 0" class="p-8 text-center text-gray-400">
        No tags found
      </div>
    </div>
  </div>
</div>

<script>
  function tagDetailsTable() {
    return {
      tags: [],
      headers: [],

      async init() {
        await this.loadTags();
        setInterval(() => this.loadTags(), 1000);
      },

      async loadTags() {
        try {
          const response = await fetch("{{ url_for('get_tags') }}");
          if (response.ok) {
            const data = await response.json();
            this.tags = Array.isArray(data) ? data : data.tags || [];

            // Extract headers from first tag
            if (this.tags.length > 0 && this.headers.length === 0) {
              this.headers = Object.keys(this.tags[0]);
            }
          }
        } catch (error) {
          console.error("Error loading tags:", error);
        }
      },

      formatValue(value, header) {
        if (value === null || value === undefined) {
          return "-";
        }

        // Format timestamp to show only HMS
        if (
          header.toLowerCase().includes("timestamp") ||
          header.toLowerCase().includes("time")
        ) {
          try {
            const date = new Date(value);
            if (!isNaN(date.getTime())) {
              return date.toLocaleTimeString("pt-BR", {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
              });
            }
          } catch (e) {
            // If parsing fails, return original value
          }
        }

        return value;
      },
    };
  }
</script>
